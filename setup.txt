Backend :-

npm init -y

npm i express cors dotenv cookie-parser date-fns bcrypt jsonwebtoken passport passport-jwt mongoose qrcode resend speakeasy uuid zod 

Dev-dependencies + ts;

npm i @types/bcrypt @types/dotenv @types/cors @types/cookie-parser @types/express @types/jsonwebtoken @types/mongoose @types/passport @types/passport-jwt @types/qrcode @types/speakeasy ts-node-dev typescript

command to create ts.config.json => npx tsc --init 

setup package.json + ts.config.json

"server":"ts-node-dev --files ./src/server.ts",
"build":"tsc && cp ./package.json ./dist",
"start":"node dist/server.js"

now modify the ts.config.json file {
    target,es2023
    rootDir"./src,
    outDir:"./dist,
    add these two things
     "include": ["src/**/*.ts", "@types"],
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


// middleware setup 

asyncHandler() for controllers / routes
errorHandler() for getting what kind of error is;

// we have to setup certain things for make our work easy and have proper error and type of error handling;

=> suppose many time .env file not works properly , not give the value correctly so we need a way to handle this in all senairios,

so we make first the utility function getEnviouments which take two params key, defaulvalue ok based on that it gives us the value always;

so using this function we setup the app.config.ts file ok

// now there are many types of errors in backend terms so ham har baar sabhi ko remember or correctly nhi us kr pate to hme ek centralize chij setup krni hogi ok;

first we make enum like all of the types or error occured;
secodn we make the http.config.ts file in which we setup the statusCode for all types of errors and return HTTPSTATUS and HttpsStatusCode type so that we use these in AppError class and also in setup of errorHandler for AppError class ok;

ðŸ”´now our work to setup the routes;


//Some myths about new Schema() vs new mongoose.Schema()

Both are the same ok, have same features, methods, etc.

userId : mongoose.Schema.Types.ObjectId => we do this in verification code model to stablish a relation b/w code model and user model,

 userId:{
        type:mongoose.Schema.Types.ObjectId,
        ref:"User", // pointing to that User model
        required:true,
        index:true
      } 

Indexes in MongoDB are used to improve the efficiency of queries. When you set index: true for a field, Mongoose instructs MongoDB to create an index on that field. This makes searches, sorts, and other operations involving that field faster.


code: {
    type: String,
    required: true,
    unique: true,
    default: generateUniqueCodes, // generate unique codes;
},

Mongoose Model Definition with Collection Name
=> means jab user khud ko register karega tab usko liye  ek alag se verification code ki collection create ho jygi jisme code hoga for verify that email, or reset-password ok


//User registered successfuly ok;

//=> Login user (Here comes the main stuff):-

// sabse phle hme user ke credentials ko check and verify krna hai ok,
then hme us user ke liye using  that userid session collection create krni hai, ab jab jab user har bar login krega uske liye new session create hoge ya old wale verify hoge sayd;

// ab hme based on userId and sessionID user ke liye accesstoken and refresh token create krne hai or unhe har request pe fir verify bhi krna hai 

//after creating this all stuff hme tokens ko cookies me store krna hai ;

we create the one seprate file which contain all things like methods for set cookies and delete cookies including types, and options for cookies.



// verify-user-email:-

first we get the code fromn the req.body; and also verify that code using the verificationschema ok;

now firts we check code is valid; so we findOne code on the verificationModel collection ok , based on code, type, exires.

Note how Here code expritaion works;
on register user time we set the exires time for code is 45 minutes ok
now when we find the document using that code, type and expires we simley put logic like

{$gt : new Date()} => means only us documnet ko retun kro jiska time ab se 45 minutes or current time se jyada ho basicalyy;

// now we have to find user using userId present in code and update the field isEamailVerifed and also doing {new : true} so updated document reflects immidiatly;

after all stuff we simpley await validcode.deleteOne() clear from collection ok
























details about cookie :-
options:[
  maxAge : how long the cookie should be lived (life),
  expires: exact time when cookis is expires,
           httpOnly: means cookie is not accessible with javascript,which is best for securty purpose, always do it,
  secure: as we know cookie is send with every request to server, so   by enable it cookie is send only over HTTPS (secure protocol) not     over HTTP ok;

  samesite: cookies are sent with cross-site request,cors, useful for preventing CSRF attacks :- types are ,
      "strict" : cookies sent only for same site,
      "lax": cookies sent for top level navigation (GET request),
      "none": cookies sent for all request,
  
  path: defines the URL path for which the cookie is valid, eg: /admin,

  domain: specify the domain for which the cookie is valid.This allow sub domain to share cookies eg: example.com,

  signed: when set to true, the cookies is signed using the secret key for added integrity.This works with cookie-parser siging functionality.
]